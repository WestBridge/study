C++:
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        vector<int> cur;
        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[0].size();j++){
                if(board[i][j]==word[0]){
                    cur.push_back(i*board[0].size()+j+1);
                    if(isMatchNext(board,word,i,j,1,cur)) 
                      return true;
                    else 
                      cur.pop_back();
                }
            }
        }
        return false;
        
    }
    bool isMatchNext(vector<vector<char>>& board,string word,int i,int j,int pos,vector<int> &cur){
        
        if(pos>=word.size()) return true;
        vector<int>::iterator it;
        
        if(i-1>=0&&board[i-1][j]==word[pos]){ 
          it=find(cur.begin(),cur.end(),(i-1)*board[0].size()+j+1);
          if (it!=cur.end()) ;
          else{
            cur.push_back((i-1)*board[0].size()+j+1);
            if(isMatchNext(board,word,i-1,j,pos+1,cur)) 
              return true;
            else
              cur.pop_back();
          }
        }
        if(j+1<board[0].size()&&board[i][j+1]==word[pos]) {
          it=find(cur.begin(),cur.end(),i*board[0].size()+j+2);
          if (it!=cur.end()) ;
          else{
            cur.push_back(i*board[0].size()+j+2);
            if(isMatchNext(board,word,i,j+1,pos+1,cur)) 
              return true;
            else
              cur.pop_back();
          }
        }
        if(i+1<board.size()&&board[i+1][j]==word[pos]) {
          it=find(cur.begin(),cur.end(),(i+1)*board[0].size()+j+1);
          if (it!=cur.end()) ;
          else{
             cur.push_back((i+1)*board[0].size()+j+1);
             if(isMatchNext(board,word,i+1,j,pos+1,cur)) 
                return true;
             else
              cur.pop_back();
          }
        }
        if(j-1>=0&&board[i][j-1]==word[pos]) {
          it=find(cur.begin(),cur.end(),i*board[0].size()+j);
          if (it!=cur.end()) ;
          else{
             cur.push_back(i*board[0].size()+j);
             if(isMatchNext(board,word,i,j-1,pos+1,cur)) 
               return true;
             else
              cur.pop_back();
          }
        }
        return false;
    }

};
